// HSE Observation Form PDF Export
// Generates PDF matching the official template layout with photos

import jsPDF from 'jspdf';
import { compressImage, COMPRESSION_PRESETS } from './imageCompression';

/**
 * Interface for observation data
 */
export interface ObservationData {
  id: string;
  itemNo: string;
  categoryId: number;
  categoryName: string;
  itemName: string;
  photos: string[];
  observation: string;
  location: string;
  actionNeeded: string;
  time: string;
  date: string;
  status: string;
  hazards: string;
  remarks: string;
}

/**
 * Interface for HSE Observation export data
 */
export interface HSEObservationFormData {
  contractor: string;
  location: string;
  date: string;
  inspectedBy: string;
  workActivity: string;
  observations: ObservationData[];
}

/**
 * Load theta logo as base64 data URL
 */
async function loadThetaLogo(): Promise<string> {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'Anonymous';
    img.onload = async () => {
      try {
        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        if (ctx) {
          ctx.drawImage(img, 0, 0);
          const dataURL = canvas.toDataURL('image/png');
          // Compress logo for faster loading
          const compressed = await compressImage(dataURL, COMPRESSION_PRESETS.logo);
          resolve(compressed);
        } else {
          reject(new Error('Failed to get canvas context'));
        }
      } catch (error) {
        reject(error);
      }
    };
    img.onerror = () => reject(new Error('Failed to load logo'));
    img.src = '/theta-logo.png';
  });
}

/**
 * Generate HSE Observation Form PDF matching the template
 * Template shows 2 observations per page
 */
export async function generateHSEObservationPDF(data: HSEObservationFormData): Promise<jsPDF> {
  const doc = new jsPDF('portrait', 'mm', 'a4');
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 10;
  const observationsPerPage = 2;

  // Load the theta logo
  let logoDataUrl: string | null = null;
  try {
    logoDataUrl = await loadThetaLogo();
  } catch (error) {
    console.warn('Could not load theta logo:', error);
  }

  // Process observations in groups of 2
  for (let i = 0; i < data.observations.length; i += observationsPerPage) {
    if (i > 0) {
      doc.addPage();
    }

    let yPosition = margin;

    // Draw header once per page
    drawHeader(doc, data, yPosition, logoDataUrl);
    yPosition += 20;

    // Draw "Item No." gray header bar
    doc.setFillColor(200, 200, 200);
    doc.setDrawColor(0);
    doc.setLineWidth(0.5);
    doc.rect(margin, yPosition, pageWidth - 2 * margin, 8, 'FD');
    doc.setFontSize(9);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(0);
    doc.text('Item', margin + 2, yPosition + 5.5);
    doc.text('No.', margin + 2, yPosition + 5.5 + 2.5);
    yPosition += 8;

    // Draw up to 2 observations on this page
    const observationsOnPage = data.observations.slice(i, i + observationsPerPage);
    observationsOnPage.forEach((observation, idx) => {
      const observationHeight = (pageHeight - yPosition - margin) / observationsPerPage;
      drawObservation(doc, observation, margin, yPosition, pageWidth - 2 * margin, observationHeight);
      yPosition += observationHeight;
    });
  }

  return doc;
}

/**
 * Draw header section with theta logo and location
 */
function drawHeader(doc: jsPDF, data: HSEObservationFormData, yPosition: number, logoDataUrl: string | null): void {
  const pageWidth = doc.internal.pageSize.getWidth();
  const margin = 10;

  // Draw header box with border
  doc.setDrawColor(0);
  doc.setLineWidth(0.5);
  doc.rect(margin, yPosition, pageWidth - 2 * margin, 18);

  // Vertical divider for logo section
  doc.line(margin + 45, yPosition, margin + 45, yPosition + 18);

  // Draw theta logo image (left box)
  if (logoDataUrl) {
    try {
      // Logo dimensions - adjust to fit nicely in the box
      const logoWidth = 35;
      const logoHeight = 12;
      const logoX = margin + 5;
      const logoY = yPosition + 3;
      doc.addImage(logoDataUrl, 'PNG', logoX, logoY, logoWidth, logoHeight);
    } catch (error) {
      console.error('Error adding logo to PDF:', error);
      // Fallback to text if image fails
      doc.setFontSize(16);
      doc.setFont('helvetica', 'bold');
      doc.setTextColor(0);
      doc.text('theta', margin + 8, yPosition + 12);
    }
  } else {
    // Fallback to text logo if image not loaded
    doc.setFontSize(16);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(0);
    doc.text('theta', margin + 8, yPosition + 12);
  }

  // Title "THETA EDGE BERHAD" (center-right section)
  doc.setTextColor(0);
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.text('THETA EDGE BERHAD', pageWidth / 2 + 15, yPosition + 9, { align: 'center' });

  // Location data (actual location from HSE Inspection, not the label "Location")
  doc.setFontSize(10);
  doc.setFont('helvetica', 'normal');
  doc.text(data.location || '', pageWidth / 2 + 15, yPosition + 14, { align: 'center' });

  doc.setTextColor(0);
}

/**
 * Draw a single observation matching the template layout
 */
function drawObservation(
  doc: jsPDF,
  observation: ObservationData,
  x: number,
  y: number,
  width: number,
  maxHeight: number
): void {
  const startY = y;
  doc.setDrawColor(0);
  doc.setLineWidth(0.5);

  // Item number (left column)
  const itemNoWidth = 15;
  doc.rect(x, y, itemNoWidth, maxHeight);
  doc.setFontSize(11);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0);
  doc.text(`${observation.itemNo}.`, x + itemNoWidth / 2, y + 8, { align: 'center' });

  // Main content area
  const contentX = x + itemNoWidth;
  const contentWidth = width - itemNoWidth;
  let contentY = y;

  // Photo area (takes about 60% of height)
  const photoHeight = maxHeight * 0.6;
  doc.rect(contentX, contentY, contentWidth, photoHeight);

  if (observation.photos && observation.photos.length > 0) {
    drawPhotosInGrid(doc, observation.photos, contentX, contentY, contentWidth, photoHeight);
  }

  contentY += photoHeight;

  // Details table area
  const tableHeight = maxHeight - photoHeight;
  drawCompactDetailsTable(doc, observation, contentX, contentY, contentWidth, tableHeight);
}

/**
 * Draw photos in a grid layout
 */
function drawPhotosInGrid(
  doc: jsPDF,
  photos: string[],
  x: number,
  y: number,
  width: number,
  height: number
): void {
  const photosToShow = photos.slice(0, 5);
  const photoCount = photosToShow.length;

  if (photoCount === 0) return;

  // Calculate grid layout
  let cols = 2;
  let rows = Math.ceil(photoCount / cols);

  if (photoCount === 1) {
    cols = 1;
    rows = 1;
  }

  const photoWidth = (width / cols) - 2;
  const photoHeight = (height / rows) - 2;

  photosToShow.forEach((photo, index) => {
    const col = index % cols;
    const row = Math.floor(index / cols);
    const photoX = x + col * (width / cols) + 1;
    const photoY = y + row * (height / rows) + 1;

    try {
      doc.addImage(photo, 'JPEG', photoX, photoY, photoWidth, photoHeight, undefined, 'FAST');
    } catch (error) {
      console.error('Error adding image to PDF:', error);
      doc.setDrawColor(200);
      doc.rect(photoX, photoY, photoWidth, photoHeight);
    }
  });
}

/**
 * Draw compact details table matching the template
 */
function drawCompactDetailsTable(
  doc: jsPDF,
  observation: ObservationData,
  x: number,
  y: number,
  width: number,
  height: number
): void {
  const rowHeight = height / 4;
  const labelColWidth = 35;
  const leftColWidth = width * 0.6;
  const rightColWidth = width * 0.4;

  doc.setDrawColor(0);
  doc.setLineWidth(0.5);

  // Draw table grid
  // Outer border
  doc.rect(x, y, width, height);

  // Vertical line separating left and right columns
  doc.line(x + leftColWidth, y, x + leftColWidth, y + height);

  // Horizontal lines
  for (let i = 1; i < 4; i++) {
    doc.line(x, y + rowHeight * i, x + width, y + rowHeight * i);
  }

  // Vertical line for label column in left side
  doc.line(x + labelColWidth, y, x + labelColWidth, y + height);

  // Vertical line for label column in right side
  const rightLabelWidth = 18;
  doc.line(x + leftColWidth + rightLabelWidth, y, x + leftColWidth + rightLabelWidth, y + height);

  // Horizontal line in right column (between Status and Hazards)
  doc.line(x + leftColWidth, y + rowHeight * 2 + rowHeight / 2, x + width, y + rowHeight * 2 + rowHeight / 2);

  doc.setTextColor(0);
  doc.setFontSize(8);

  // Row 1: Observation | Time
  doc.setFont('helvetica', 'bold');
  doc.text('Observation:', x + 2, y + 4);
  doc.setFont('helvetica', 'normal');
  const obsLines = doc.splitTextToSize(observation.observation || '', leftColWidth - labelColWidth - 4);
  doc.text(obsLines, x + labelColWidth + 2, y + 4);

  doc.setFont('helvetica', 'bold');
  doc.text('Time:', x + leftColWidth + 2, y + 4);
  doc.setFont('helvetica', 'normal');
  doc.text(observation.time || '', x + leftColWidth + rightLabelWidth + 2, y + 4);

  // Row 2: Location | Date
  doc.setFont('helvetica', 'bold');
  doc.text('Location:', x + 2, y + rowHeight + 4);
  doc.setFont('helvetica', 'normal');
  const locLines = doc.splitTextToSize(observation.location || '', leftColWidth - labelColWidth - 4);
  doc.text(locLines, x + labelColWidth + 2, y + rowHeight + 4);

  doc.setFont('helvetica', 'bold');
  doc.text('Date:', x + leftColWidth + 2, y + rowHeight + 4);
  doc.setFont('helvetica', 'normal');
  doc.text(observation.date || '', x + leftColWidth + rightLabelWidth + 2, y + rowHeight + 4);

  // Row 3: Action needs to be taken | Status & Hazards
  doc.setFont('helvetica', 'bold');
  doc.text('Action needs', x + 2, y + rowHeight * 2 + 4);
  doc.text('to be taken:', x + 2, y + rowHeight * 2 + 7);
  doc.setFont('helvetica', 'normal');
  const actionLines = doc.splitTextToSize(observation.actionNeeded || '', leftColWidth - labelColWidth - 4);
  doc.text(actionLines, x + labelColWidth + 2, y + rowHeight * 2 + 4);

  doc.setFont('helvetica', 'bold');
  doc.text('Status:', x + leftColWidth + 2, y + rowHeight * 2 + 4);
  doc.setFont('helvetica', 'normal');
  doc.text(observation.status || '', x + leftColWidth + rightLabelWidth + 2, y + rowHeight * 2 + 4);

  doc.setFont('helvetica', 'bold');
  doc.text('Hazards:', x + leftColWidth + 2, y + rowHeight * 2 + rowHeight / 2 + 4);
  doc.setFont('helvetica', 'normal');
  const hazardLines = doc.splitTextToSize(
    observation.hazards || '',
    rightColWidth - rightLabelWidth - 4
  );
  doc.text(hazardLines, x + leftColWidth + rightLabelWidth + 2, y + rowHeight * 2 + rowHeight / 2 + 4);

  // Row 4: Remarks
  doc.setFont('helvetica', 'bold');
  doc.text('Remarks:', x + 2, y + rowHeight * 3 + 4);
  doc.setFont('helvetica', 'normal');
  const remarksLines = doc.splitTextToSize(observation.remarks || '', width - labelColWidth - 4);
  doc.text(remarksLines, x + labelColWidth + 2, y + rowHeight * 3 + 4);
}

/**
 * Download the PDF
 */
export async function downloadHSEObservationForm(
  data: HSEObservationFormData,
  filename?: string
): Promise<void> {
  const pdf = await generateHSEObservationPDF(data);
  const defaultFilename = `HSE_Observation_Form_${data.location.replace(/[^a-z0-9]/gi, '_')}_${data.date}.pdf`;
  pdf.save(filename || defaultFilename);
}

/**
 * Generate and open PDF in new window for printing
 */
export async function printHSEObservationForm(data: HSEObservationFormData): Promise<void> {
  const pdf = await generateHSEObservationPDF(data);
  const pdfBlob = pdf.output('blob');
  const url = URL.createObjectURL(pdfBlob);

  const printWindow = window.open(url, '_blank');
  if (printWindow) {
    printWindow.onload = () => {
      setTimeout(() => {
        printWindow.print();
      }, 500);
    };
  }
}
