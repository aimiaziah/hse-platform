import React, { useState, useRef, useEffect } from 'react';
import { Camera, Trash2, X } from 'lucide-react';
import { useRouter } from 'next/router';
import ProtectedRoute from '../components/ProtectedRoute';
import InspectorLayout from '../roles/inspector/layouts/InspectorLayout';
import { storage } from '../utils/storage';
import { useAuth } from '@/hooks/useAuth';

interface ObservationData {
  id: string;
  itemNo: string;
  categoryId: number;
  categoryName: string;
  itemName: string;
  photos: string[];
  observation: string;
  location: string;
  actionNeeded: string;
  time: string;
  date: string;
  status: string;
  hazards: string;
  remarks: string;
  preparedBy?: string;
  preparedByDate?: string;
  reviewedBy?: string;
  reviewedByDate?: string;
}

const HSEObservationForm: React.FC = () => {
  const router = useRouter();
  const { user } = useAuth();
  const {
    categoryId,
    categoryName,
    itemName,
    inspectionId,
    location: inspectionLocation,
    date: inspectionDate,
    editId,
  } = router.query;
  const [photos, setPhotos] = useState<string[]>([]);
  const [showCamera, setShowCamera] = useState(false);
  const [cameraLoading, setCameraLoading] = useState(false);
  const [cameraError, setCameraError] = useState<string | null>(null);
  const videoRef = useRef<HTMLVideoElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [stream, setStream] = useState<MediaStream | null>(null);
  const [isEditMode, setIsEditMode] = useState(false);

  // Auto-capture current date and time
  const [currentDateTime] = useState({
    date: new Date().toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    }),
    time: new Date().toLocaleTimeString('en-US', {
      hour: '2-digit',
      minute: '2-digit',
      hour12: true,
    }),
  });

  // Load existing observations to auto-generate Item No
  const [existingObservations, setExistingObservations] = useState<ObservationData[]>([]);
  const [autoGeneratedItemNo, setAutoGeneratedItemNo] = useState('');

  useEffect(() => {
    if (inspectionId) {
      const saved = JSON.parse(localStorage.getItem(`hse-observations-${inspectionId}`) || '[]');
      setExistingObservations(saved);
      setAutoGeneratedItemNo(`${String(saved.length + 1).padStart(2, '0')}`);
    }
  }, [inspectionId]);

  const [formData, setFormData] = useState<
    Omit<ObservationData, 'id' | 'categoryId' | 'categoryName' | 'itemName' | 'photos'>
  >({
    itemNo: '',
    observation: '',
    location: '',
    actionNeeded: '',
    time: currentDateTime.time,
    date: new Date().toISOString().split('T')[0],
    status: '',
    hazards: '',
    remarks: '',
    preparedBy: '',
    preparedByDate: new Date().toISOString().split('T')[0],
    reviewedBy: '',
    reviewedByDate: '',
  });

  // Image compression function - reduces size while maintaining quality
  const compressImage = async (base64: string, maxWidth = 1200, quality = 0.7): Promise<string> => {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas');
        let width = img.width;
        let height = img.height;

        // Calculate new dimensions while maintaining aspect ratio
        if (width > maxWidth) {
          height = (height * maxWidth) / width;
          width = maxWidth;
        }

        canvas.width = width;
        canvas.height = height;

        const ctx = canvas.getContext('2d');
        if (ctx) {
          ctx.drawImage(img, 0, 0, width, height);
          const compressed = canvas.toDataURL('image/jpeg', quality);
          const originalKB = (base64.length / 1024).toFixed(0);
          const compressedKB = (compressed.length / 1024).toFixed(0);
          console.log(`[Image Compression] ${originalKB}KB → ${compressedKB}KB (${Math.round((1 - compressed.length / base64.length) * 100)}% reduction)`);
          resolve(compressed);
        } else {
          console.warn('[Image Compression] Failed - using original');
          resolve(base64);
        }
      };
      img.onerror = () => {
        console.warn('[Image Compression] Error - using original');
        resolve(base64);
      };
      img.src = base64;
    });
  };

  useEffect(() => {
    if (autoGeneratedItemNo && !editId) {
      setFormData((prev) => ({
        ...prev,
        itemNo: autoGeneratedItemNo,
        location: inspectionLocation ? String(inspectionLocation) : prev.location,
        date: inspectionDate ? String(inspectionDate) : prev.date,
      }));
    }
  }, [autoGeneratedItemNo, inspectionLocation, inspectionDate, editId]);

  useEffect(() => {
    if (editId && inspectionId) {
      setIsEditMode(true);
      const saved = JSON.parse(localStorage.getItem(`hse-observations-${inspectionId}`) || '[]');
      const existingObs = saved.find((obs: ObservationData) => obs.id === String(editId));
      if (existingObs) {
        setFormData({
          itemNo: existingObs.itemNo,
          observation: existingObs.observation,
          location: existingObs.location,
          actionNeeded: existingObs.actionNeeded,
          time: existingObs.time,
          date: existingObs.date,
          status: existingObs.status,
          hazards: existingObs.hazards,
          remarks: existingObs.remarks,
          preparedBy: existingObs.preparedBy || '',
          preparedByDate: existingObs.preparedByDate || '',
          reviewedBy: existingObs.reviewedBy || '',
          reviewedByDate: existingObs.reviewedByDate || '',
        });
        if (existingObs.photos) {
          setPhotos(existingObs.photos);
        }
      }
    }
  }, [editId, inspectionId]);

  const handleFileUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = Array.from(e.target.files || []);
    const remainingSlots = 5 - photos.length;
    if (files.length > remainingSlots) {
      alert(`You can only add ${remainingSlots} more photo(s). Maximum 5 photos allowed.`);
      return;
    }

    for (const file of files) {
      const reader = new FileReader();
      reader.onload = async (e) => {
        const result = e.target?.result as string;
        // Compress image before adding to photos
        const compressed = await compressImage(result);
        setPhotos((prev) => [...prev, compressed]);
      };
      reader.readAsDataURL(file);
    }

    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  const startCamera = async () => {
    if (photos.length >= 5) {
      alert('Maximum 5 photos allowed. Please remove a photo first.');
      return;
    }
    setCameraLoading(true);
    setCameraError(null);
    setShowCamera(true);
    try {
      let mediaStream: MediaStream;
      try {
        mediaStream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: { ideal: 'environment' },
            width: { ideal: 1920 },
            height: { ideal: 1080 },
          },
          audio: false,
        });
      } catch (envError) {
        mediaStream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: { ideal: 1280 },
            height: { ideal: 720 },
          },
          audio: false,
        });
      }
      setStream(mediaStream);
      if (videoRef.current) {
        const video = videoRef.current;
        video.srcObject = mediaStream;
        video.setAttribute('playsinline', 'true');
        video.setAttribute('webkit-playsinline', 'true');
        video.setAttribute('autoplay', 'true');
        video.muted = true;
        video.playsInline = true;
        await new Promise<void>((resolve, reject) => {
          let attempts = 0;
          const maxAttempts = 50;
          const checkReady = async () => {
            attempts++;
            if (video.readyState >= 2 && video.videoWidth > 0 && video.videoHeight > 0) {
              try {
                await video.play();
                resolve();
              } catch (playErr) {
                if (video.readyState >= 2 && video.videoWidth > 0) {
                  resolve();
                } else {
                  reject(playErr);
                }
              }
            } else if (attempts >= maxAttempts) {
              reject(new Error('Camera timeout - video not ready after 10 seconds'));
            } else {
              setTimeout(checkReady, 200);
            }
          };
          video.addEventListener(
            'loadedmetadata',
            () => {
              resolve();
            },
            { once: true },
          );
          checkReady();
        });
        setCameraLoading(false);
      }
    } catch (error: any) {
      console.error('Error accessing camera:', error);
      const errorMsg =
        error.name === 'NotAllowedError'
          ? 'Camera permission denied. Please allow camera access.'
          : error.name === 'NotFoundError'
          ? 'No camera found on this device.'
          : 'Could not access camera. Please check permissions and ensure you are using HTTPS.';
      setCameraError(errorMsg);
      setCameraLoading(false);
      if (stream) {
        stream.getTracks().forEach((track) => track.stop());
        setStream(null);
      }
    }
  };

  const capturePhoto = async () => {
    if (videoRef.current && canvasRef.current) {
      const video = videoRef.current;
      const canvas = canvasRef.current;
      if (video.videoWidth === 0 || video.videoHeight === 0) {
        alert('Camera not ready. Please wait a moment and try again.');
        return;
      }
      const context = canvas.getContext('2d');
      if (!context) {
        alert('Failed to capture photo. Please try again.');
        return;
      }
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      context.drawImage(video, 0, 0);
      const imageData = canvas.toDataURL('image/jpeg', 0.9);
      if (imageData.length < 100) {
        alert('Failed to capture photo. Please try again.');
        return;
      }
      // Compress captured photo
      const compressed = await compressImage(imageData);
      setPhotos((prev) => [...prev, compressed]);
      stopCamera();
    }
  };

  const stopCamera = () => {
    if (stream) {
      stream.getTracks().forEach((track) => track.stop());
      setStream(null);
    }
    setShowCamera(false);
    setCameraLoading(false);
    setCameraError(null);
  };

  const removePhoto = (index: number) => {
    setPhotos((prev) => prev.filter((_, i) => i !== index));
  };

  const handleSaveAndReturn = () => {
    if (!formData.itemNo.trim()) {
      alert(
        'Item number was not auto-generated. Please return to the inspection form and try again.',
      );
      return;
    }
    if (!formData.observation.trim()) {
      alert('Please enter an observation');
      return;
    }
    if (!formData.location.trim()) {
      alert(
        'Location is required. Please fill in the Location field in the HSE Inspection form before adding observations.',
      );
      return;
    }
    const existingObservations = JSON.parse(
      localStorage.getItem(`hse-observations-${inspectionId}`) || '[]',
    );
    if (isEditMode && editId) {
      const index = existingObservations.findIndex(
        (obs: ObservationData) => obs.id === String(editId),
      );
      if (index !== -1) {
        existingObservations[index] = {
          ...existingObservations[index],
          itemNo: formData.itemNo,
          photos: photos,
          observation: formData.observation,
          location: formData.location,
          actionNeeded: formData.actionNeeded,
          time: formData.time,
          date: formData.date,
          status: formData.status,
          hazards: formData.hazards,
          remarks: formData.remarks,
          preparedBy: formData.preparedBy,
          preparedByDate: formData.preparedByDate,
          reviewedBy: formData.reviewedBy,
          reviewedByDate: formData.reviewedByDate,
        };
      }
    } else {
      const newObservation: ObservationData = {
        id: Date.now().toString(),
        itemNo: formData.itemNo,
        categoryId: Number(categoryId),
        categoryName: String(categoryName),
        itemName: String(itemName),
        photos: photos,
        observation: formData.observation,
        location: formData.location,
        actionNeeded: formData.actionNeeded,
        time: formData.time,
        date: formData.date,
        status: formData.status,
        hazards: formData.hazards,
        remarks: formData.remarks,
        preparedBy: formData.preparedBy,
        preparedByDate: formData.preparedByDate,
        reviewedBy: formData.reviewedBy,
        reviewedByDate: formData.reviewedByDate,
      };
      existingObservations.push(newObservation);
    }
    localStorage.setItem(`hse-observations-${inspectionId}`, JSON.stringify(existingObservations));
    router.push('/hse-inspection');
  };

  const handleSaveAsDraft = async () => {
    if (!formData.observation.trim()) {
      alert('Please enter an observation');
      return;
    }
    if (!formData.location.trim()) {
      alert('Location is required');
      return;
    }

    const observationRecord = {
      id: Date.now().toString(),
      observedBy: user?.name || formData.preparedBy,
      inspectorId: user?.id || '',
      location: formData.location,
      date: formData.date,
      observation: formData.observation,
      actionNeeded: formData.actionNeeded,
      hazards: formData.hazards,
      remarks: formData.remarks,
      photos: photos,
      status: 'draft',
      createdAt: new Date().toISOString(),
      savedAt: new Date().toISOString(),
    };

    try {
      // Save to database via API
      const response = await fetch('/api/inspections', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          formType: 'hse_general',
          status: 'draft',
          data: {
            isObservation: true, // Flag to identify this as observation vs inspection
            observation: observationRecord.observation,
            location: observationRecord.location,
            date: observationRecord.date,
            actionNeeded: observationRecord.actionNeeded,
            hazards: observationRecord.hazards,
            remarks: observationRecord.remarks,
            photos: observationRecord.photos,
            preparedBy: formData.preparedBy,
            preparedByDate: formData.preparedByDate,
            reviewedBy: formData.reviewedBy,
            reviewedByDate: formData.reviewedByDate,
          },
        }),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
        console.warn('Database save failed, saving to localStorage only:', errorData);

        // Save to localStorage as fallback
        const allObservations = storage.load<any[]>('hse_observations', []);
        allObservations.push(observationRecord);
        storage.save('hse_observations', allObservations);

        if (response.status === 413) {
          alert(`Photos are too large for database (${Math.round(JSON.stringify(observationRecord.photos).length / 1024)}KB).\n\nObservation saved locally only. It will appear in your Saved section.`);
        } else {
          alert(`Could not save to server (Error ${response.status}).\n\nObservation saved locally. It will appear in your Saved section.`);
        }

        router.push('/saved');
        return;
      }

      const result = await response.json();
      console.log('Observation saved to database:', result);

      // Also save to localStorage for backward compatibility
      const allObservations = storage.load<any[]>('hse_observations', []);
      allObservations.push(observationRecord);
      storage.save('hse_observations', allObservations);

      alert('Observation saved as draft!');
      router.push('/saved');
    } catch (error) {
      console.error('Error saving observation:', error);

      // Save to localStorage as fallback on network errors
      const allObservations = storage.load<any[]>('hse_observations', []);
      allObservations.push(observationRecord);
      storage.save('hse_observations', allObservations);

      alert(`Network Error: Could not connect to server.\n\nThe observation has been saved locally and will appear in your Saved section.`);
      router.push('/saved');
    }
  };

  const handleSubmitForReview = async () => {
    console.log('=== SUBMIT FOR REVIEW CLICKED ===');
    console.log('User:', user);
    console.log('FormData:', formData);

    if (!formData.observation.trim()) {
      alert('Please enter an observation');
      console.log('ERROR: No observation text');
      return;
    }
    if (!formData.location.trim()) {
      alert('Location is required');
      console.log('ERROR: No location');
      return;
    }

    const observationRecord = {
      id: Date.now().toString(),
      observedBy: user?.name || formData.preparedBy,
      inspectorId: user?.id || '',
      location: formData.location,
      date: formData.date,
      observation: formData.observation,
      actionNeeded: formData.actionNeeded,
      hazards: formData.hazards,
      remarks: formData.remarks,
      photos: photos,
      status: 'pending_review',
      createdAt: new Date().toISOString(),
      savedAt: new Date().toISOString(),
      submittedAt: new Date().toISOString(),
    };

    console.log('Observation Record:', observationRecord);
    alert(`DEBUG: About to save observation\n\nID: ${observationRecord.id}\nLocation: ${observationRecord.location}\nObserver: ${observationRecord.observedBy}\nInspector ID: ${observationRecord.inspectorId}\nPhotos: ${observationRecord.photos.length}`);

    try {
      // Save to database via API
      const response = await fetch('/api/inspections', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          formType: 'hse_general',
          status: 'pending_review',
          data: {
            isObservation: true, // Flag to identify this as observation vs inspection
            observation: observationRecord.observation,
            location: observationRecord.location,
            date: observationRecord.date,
            actionNeeded: observationRecord.actionNeeded,
            hazards: observationRecord.hazards,
            remarks: observationRecord.remarks,
            photos: observationRecord.photos,
            preparedBy: formData.preparedBy,
            preparedByDate: formData.preparedByDate,
            reviewedBy: formData.reviewedBy,
            reviewedByDate: formData.reviewedByDate,
          },
        }),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
        let errorMessage = 'Failed to submit observation.';

        if (response.status === 413) {
          errorMessage = `Payload Too Large: Your observation has too much data (${Math.round(JSON.stringify(observationRecord.photos).length / 1024)}KB of photos).\n\nThe photos are too large for the database. Try:\n1. Reducing the number of photos\n2. Using compressed images\n\nThe observation will be saved locally only.`;

          // Save to localStorage as fallback
          const allObservations = storage.load<any[]>('hse_observations', []);
          allObservations.push(observationRecord);
          storage.save('hse_observations', allObservations);

          alert(errorMessage);
          router.push('/saved');
          return;
        } else if (response.status === 401) {
          errorMessage = 'Authentication Error: Your session has expired. Please log in again.';
        } else if (response.status === 403) {
          errorMessage = 'Permission Error: You do not have permission to submit observations.';
        } else if (response.status === 500) {
          errorMessage = `Server Error: ${errorData.error || errorData.details || 'Internal server error'}`;
        } else {
          errorMessage = `${errorData.error || errorData.details || 'Unknown error'}\n\nStatus: ${response.status}`;
        }

        console.error('Observation submission error:', errorMessage, errorData);
        alert(`Submission Error:\n\n${errorMessage}`);
        return;
      }

      const result = await response.json();
      console.log('✅ Observation submitted to database:', result);

      alert('Observation submitted for review successfully!');
      router.push('/inspector/forms');
    } catch (error) {
      console.error('❌ Error submitting observation:', error);

      // Save to localStorage as fallback on network errors
      const allObservations = storage.load<any[]>('hse_observations', []);
      console.log('FALLBACK: Current observations:', allObservations.length);
      allObservations.push(observationRecord);
      storage.save('hse_observations', allObservations);
      console.log('FALLBACK: Saved to localStorage. New count:', allObservations.length);

      // Verify it was saved
      const verifyObservations = storage.load<any[]>('hse_observations', []);
      console.log('✅ FALLBACK VERIFIED:', verifyObservations.length, 'observations');

      alert(`⚠️ Network Error: Could not connect to server.\n\nThe observation has been saved locally (${verifyObservations.length} total).\n\nError: ${error instanceof Error ? error.message : 'Unknown error'}`);
      router.push('/saved');
    }
  };

  const handleCancel = () => {
    if (stream) {
      stream.getTracks().forEach((track) => track.stop());
    }
    // If we have an inspectionId, go back to the inspection form
    // Otherwise, go to the forms list
    if (inspectionId) {
      router.push('/hse-inspection');
    } else {
      router.push('/inspector/forms');
    }
  };

  useEffect(() => {
    return () => {
      if (stream) {
        stream.getTracks().forEach((track) => track.stop());
      }
    };
  }, [stream]);

  return (
    <ProtectedRoute requiredPermission="canCreateInspections">
      <InspectorLayout>
        <div className="min-h-screen bg-gray-50 p-4 pb-20">
          <div className="max-w-2xl mx-auto px-4 py-4">
            {/* Header */}
            <div className="bg-white rounded-lg border border-blue-200 p-4 mb-4 shadow-sm">
              <div className="flex items-center mb-3">
                <button
                  onClick={handleCancel}
                  className="mr-3 hover:bg-gray-100 p-2 rounded-lg transition-colors text-blue-600 text-sm"
                  aria-label="Go back"
                >
                  ← Back
                </button>
                <h1 className="text-lg font-bold text-gray-800 flex-1">
                  {isEditMode ? 'Edit Observation' : 'Observation Form'}
                </h1>
              </div>
              <div className="rounded border border-blue-200 p-3 space-y-1">
                <p className="text-sm text-gray-700">
                  <strong>Category:</strong> {categoryName}
                </p>
                <p className="text-sm text-gray-700">
                  <strong>Item:</strong> {itemName}
                </p>
              </div>
            </div>

            {/* Inspection Context Info */}
            <div className="bg-white rounded-lg border border-blue-200 p-4 mb-4 shadow-sm">
              <h3 className="text-sm font-semibold text-gray-700 mb-3">Inspection Details</h3>
              <div className="grid grid-cols-2 gap-3">
                <div>
                  <span className="text-gray-600 text-xs">Location</span>
                  <p className="font-medium text-gray-800 text-sm">
                    {inspectionLocation || formData.location}
                  </p>
                </div>
                <div>
                  <span className="text-gray-600 text-xs">Date</span>
                  <p className="font-medium text-gray-800 text-sm">{currentDateTime.date}</p>
                </div>
                <div>
                  <span className="text-gray-600 text-xs">Time</span>
                  <p className="font-medium text-gray-800 text-sm">{currentDateTime.time}</p>
                </div>
                <div>
                  <span className="text-gray-600 text-xs">Item No.</span>
                  <p className="font-medium text-gray-800 text-sm">{formData.itemNo}</p>
                </div>
              </div>
            </div>

            {/* Continuous Observations Table */}
            {existingObservations.length > 0 && (
              <div className="bg-white rounded-lg border border-blue-200 p-4 mb-4 shadow-sm">
                <h2 className="text-sm font-semibold text-gray-800 mb-3">
                  Observations ({existingObservations.length})
                </h2>
                <div className="rounded border border-blue-200 overflow-hidden">
                  {existingObservations.map((obs, index) => (
                    <div key={obs.id} className="border-b border-blue-200 last:border-b-0">
                      <div className="bg-blue-50 px-4 py-2 font-medium text-blue-800 border-b border-blue-200 text-sm">
                        {index + 1}.
                      </div>
                      {obs.photos && obs.photos.length > 0 && (
                        <div className="px-4 py-3 bg-white border-b border-blue-200">
                          <div className="flex gap-2 overflow-x-auto">
                            {obs.photos.map((photo, photoIndex) => (
                              <img
                                key={photoIndex}
                                src={photo}
                                alt={`Item ${index + 1} photo ${photoIndex + 1}`}
                                className="h-32 object-cover rounded border border-blue-200"
                              />
                            ))}
                          </div>
                        </div>
                      )}
                      <div className="grid grid-cols-1 md:grid-cols-2 bg-white">
                        <div className="border-r border-blue-200">
                          <div className="px-4 py-3 border-b border-blue-200">
                            <div className="text-xs font-medium text-gray-700 mb-1">
                              Observation:
                            </div>
                            <div className="text-sm text-gray-800">{obs.observation}</div>
                          </div>
                          <div className="px-4 py-3 border-b border-blue-200 md:border-b-0">
                            <div className="text-xs font-medium text-gray-700 mb-1">Location:</div>
                            <div className="text-sm text-gray-800">{obs.location}</div>
                          </div>
                          <div className="px-4 py-3 border-b border-blue-200 md:border-b-0">
                            <div className="text-xs font-medium text-gray-700 mb-1">
                              Action Needed:
                            </div>
                            <div className="text-sm text-gray-800">{obs.actionNeeded || '-'}</div>
                          </div>
                          <div className="px-4 py-3 md:border-t md:border-blue-200">
                            <div className="text-xs font-medium text-gray-700 mb-1">Remarks:</div>
                            <div className="text-sm text-gray-800">{obs.remarks || '-'}</div>
                          </div>
                        </div>
                        <div>
                          <div className="px-4 py-3 border-b border-blue-200">
                            <div className="text-xs font-medium text-gray-700 mb-1">Time:</div>
                            <div className="text-sm text-gray-800">{obs.time}</div>
                          </div>
                          <div className="px-4 py-3 border-b border-blue-200">
                            <div className="text-xs font-medium text-gray-700 mb-1">Date:</div>
                            <div className="text-sm text-gray-800">{obs.date}</div>
                          </div>
                          <div className="px-4 py-3 border-b border-blue-200">
                            <div className="text-xs font-medium text-gray-700 mb-1">Status:</div>
                            <div className="text-sm text-gray-800 font-medium">
                              {obs.status || '-'}
                            </div>
                          </div>
                          <div className="px-4 py-3">
                            <div className="text-xs font-medium text-gray-700 mb-1">Hazards:</div>
                            <div className="text-sm text-gray-800">{obs.hazards || '-'}</div>
                          </div>
                        </div>
                      </div>
                      {(obs.preparedBy || obs.reviewedBy) && (
                        <div className="px-4 py-3 bg-blue-50 border-t border-blue-200">
                          <div className="text-xs font-medium text-blue-800 mb-2">Signatures</div>
                          <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                            {obs.preparedBy && (
                              <div>
                                <div className="text-xs text-gray-700">Prepared by:</div>
                                <div className="text-sm font-medium text-gray-800">
                                  {obs.preparedBy}
                                </div>
                                {obs.preparedByDate && (
                                  <div className="text-xs text-gray-600">
                                    {new Date(obs.preparedByDate).toLocaleDateString()}
                                  </div>
                                )}
                              </div>
                            )}
                            {obs.reviewedBy && (
                              <div>
                                <div className="text-xs text-gray-700">Review by:</div>
                                <div className="text-sm font-medium text-gray-800">
                                  {obs.reviewedBy}
                                </div>
                                {obs.reviewedByDate && (
                                  <div className="text-xs text-gray-600">
                                    {new Date(obs.reviewedByDate).toLocaleDateString()}
                                  </div>
                                )}
                              </div>
                            )}
                          </div>
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            )}

            {/* New Observation Form Header */}
            <div className="bg-blue-600 border border-blue-600 p-4 mb-4 rounded-lg shadow-sm">
              <h2 className="text-lg font-bold text-white flex items-center gap-2">
                {isEditMode ? 'Edit Observation Details' : 'Add New Observation'}
                {!isEditMode && existingObservations.length > 0 && (
                  <span className="text-sm font-normal border border-white px-3 py-1 rounded">
                    Item #{existingObservations.length + 1}
                  </span>
                )}
                {isEditMode && formData.itemNo && (
                  <span className="text-sm font-normal border border-white px-3 py-1 rounded">
                    {formData.itemNo}
                  </span>
                )}
              </h2>
            </div>

            {/* Photo Section */}
            <div className="bg-white rounded-lg border border-blue-200 p-4 mb-4 shadow-sm">
              <div className="flex items-center justify-between mb-3">
                <h2 className="text-sm font-semibold text-gray-800">Photos</h2>
                <span className="text-xs text-gray-600 font-medium">{photos.length} / 5</span>
              </div>
              {photos.length > 0 && (
                <div className="grid grid-cols-2 gap-3 mb-4">
                  {photos.map((photo, index) => (
                    <div key={index} className="relative group">
                      <img
                        src={photo}
                        alt={`Observation ${index + 1}`}
                        className="w-full h-32 object-cover rounded-lg border-2 border-blue-200"
                      />
                      <button
                        onClick={() => removePhoto(index)}
                        className="absolute top-2 right-2 bg-red-500 text-white p-1.5 rounded-full hover:bg-red-600 transition-colors shadow-lg opacity-90 group-hover:opacity-100"
                        aria-label={`Remove photo ${index + 1}`}
                      >
                        <Trash2 className="w-4 h-4" />
                      </button>
                    </div>
                  ))}
                </div>
              )}
              {photos.length < 5 && (
                <div className="space-y-2">
                  <button
                    onClick={startCamera}
                    className="w-full bg-blue-600 text-white px-4 py-2 font-medium hover:bg-blue-700 transition-colors rounded-lg"
                  >
                    Take Photo
                  </button>
                  <button
                    onClick={() => fileInputRef.current?.click()}
                    className="w-full border-2 border-blue-600 text-blue-600 px-4 py-2 font-medium hover:bg-blue-50 transition-colors rounded-lg"
                  >
                    Upload Photo
                  </button>
                  <input
                    ref={fileInputRef}
                    type="file"
                    accept="image/*"
                    multiple
                    onChange={handleFileUpload}
                    className="hidden"
                  />
                </div>
              )}
              {photos.length === 0 && (
                <div className="border-2 border-dashed border-blue-200 rounded-xl p-8 text-center bg-blue-50">
                  <Camera className="w-12 h-12 text-blue-400 mx-auto mb-2" />
                  <p className="text-blue-600 text-sm">No photos added yet</p>
                </div>
              )}
            </div>

            {/* Form Fields */}
            <div className="bg-white rounded-lg border border-blue-200 p-4 mb-4 space-y-4 shadow-sm">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Location <span className="text-red-500">*</span>
                </label>
                <input
                  type="text"
                  value={formData.location}
                  onChange={(e) => setFormData({ ...formData, location: e.target.value })}
                  className="w-full px-4 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  placeholder="Enter location (e.g., Site A, Building 2, Floor 3)"
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Observation <span className="text-red-500">*</span>
                </label>
                <textarea
                  value={formData.observation}
                  onChange={(e) => setFormData({ ...formData, observation: e.target.value })}
                  rows={4}
                  className="w-full px-4 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none"
                  placeholder="Describe what you observed..."
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Action Needed
                </label>
                <textarea
                  value={formData.actionNeeded}
                  onChange={(e) => setFormData({ ...formData, actionNeeded: e.target.value })}
                  rows={3}
                  className="w-full px-4 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none"
                  placeholder="Describe required actions..."
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Status</label>
                <select
                  value={formData.status}
                  onChange={(e) => setFormData({ ...formData, status: e.target.value })}
                  className="w-full px-4 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white"
                >
                  <option value="">Select status</option>
                  <option value="Open">Open</option>
                  <option value="Closed">Closed</option>
                  <option value="Ongoing">Ongoing</option>
                </select>
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Hazards Identified
                </label>
                <input
                  type="text"
                  value={formData.hazards}
                  onChange={(e) => setFormData({ ...formData, hazards: e.target.value })}
                  className="w-full px-4 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  placeholder="Identify potential hazards"
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Remarks</label>
                <textarea
                  value={formData.remarks}
                  onChange={(e) => setFormData({ ...formData, remarks: e.target.value })}
                  rows={3}
                  className="w-full px-4 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none"
                  placeholder="Additional remarks or notes..."
                />
              </div>
            </div>

            {/* Signature Section */}
            <div className="bg-white rounded-lg border border-blue-200 p-4 mb-4 shadow-sm">
              <h3 className="text-sm font-semibold text-gray-800 mb-4">Signatures</h3>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div className="border-2 border-blue-200 p-4 rounded-lg">
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Prepared by:
                  </label>
                  <input
                    type="text"
                    value={formData.preparedBy}
                    onChange={(e) => setFormData({ ...formData, preparedBy: e.target.value })}
                    className="w-full px-4 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent mb-3"
                    placeholder="Name"
                  />
                  <label className="block text-xs font-medium text-gray-600 mb-1">Date:</label>
                  <input
                    type="date"
                    value={formData.preparedByDate}
                    onChange={(e) => setFormData({ ...formData, preparedByDate: e.target.value })}
                    className="w-full px-4 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  />
                </div>
                <div className="border-2 border-blue-200 p-4 rounded-lg">
                  <label className="block text-sm font-medium text-gray-700 mb-2">Review by:</label>
                  <input
                    type="text"
                    value={formData.reviewedBy}
                    onChange={(e) => setFormData({ ...formData, reviewedBy: e.target.value })}
                    className="w-full px-4 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent mb-3"
                    placeholder="Name"
                  />
                  <label className="block text-xs font-medium text-gray-600 mb-1">Date:</label>
                  <input
                    type="date"
                    value={formData.reviewedByDate}
                    onChange={(e) => setFormData({ ...formData, reviewedByDate: e.target.value })}
                    className="w-full px-4 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  />
                </div>
              </div>
            </div>

            {/* Action Buttons */}
            <div className="space-y-3 px-4">
              {inspectionId ? (
                <div className="flex gap-3">
                  <button
                    onClick={handleCancel}
                    className="flex-1 border-2 border-blue-600 text-blue-600 py-3 font-medium hover:bg-blue-50 transition-colors rounded-lg"
                  >
                    Cancel
                  </button>
                  <button
                    onClick={handleSaveAndReturn}
                    className="flex-1 bg-blue-600 text-white py-3 font-medium hover:bg-blue-700 transition-colors rounded-lg"
                  >
                    {isEditMode ? 'Update' : 'Save'}
                  </button>
                </div>
              ) : (
                <>
                  <div className="flex gap-3">
                    <button
                      onClick={handleCancel}
                      className="flex-1 border-2 border-gray-300 text-gray-700 py-3 font-medium hover:bg-gray-50 transition-colors rounded-lg"
                    >
                      Cancel
                    </button>
                    <button
                      onClick={handleSaveAsDraft}
                      className="flex-1 border-2 border-blue-600 text-blue-600 py-3 font-medium hover:bg-blue-50 transition-colors rounded-lg"
                    >
                      Save as Draft
                    </button>
                  </div>
                  <button
                    onClick={handleSubmitForReview}
                    className="w-full bg-blue-600 text-white py-3 font-medium hover:bg-blue-700 transition-colors rounded-lg"
                  >
                    Submit for Review
                  </button>
                </>
              )}
            </div>
          </div>

          {/* Camera Modal */}
          {showCamera && (
            <div className="fixed inset-0 bg-black bg-opacity-95 flex items-center justify-center p-4 z-50">
              <div className="bg-white rounded-2xl p-4 max-w-2xl w-full">
                <div className="flex items-center justify-between mb-4">
                  <h3 className="text-lg font-semibold text-gray-800">Take Photo</h3>
                  <button
                    onClick={stopCamera}
                    className="text-gray-500 hover:text-gray-700 hover:bg-gray-100 p-2 rounded-full transition-colors"
                    aria-label="Close camera"
                  >
                    <X className="w-6 h-6" />
                  </button>
                </div>
                {cameraLoading && (
                  <div
                    className="w-full rounded-xl mb-4 bg-blue-600 flex items-center justify-center"
                    style={{ minHeight: '300px' }}
                  >
                    <div className="text-center">
                      <Camera className="w-12 h-12 text-white mx-auto mb-3 animate-pulse" />
                      <p className="text-white text-sm">Initializing camera...</p>
                      <p className="text-blue-300 text-xs mt-1">
                        Please allow camera access if prompted
                      </p>
                    </div>
                  </div>
                )}
                {cameraError && !cameraLoading && (
                  <div
                    className="w-full rounded-xl mb-4 bg-red-50 border-2 border-red-200 p-6 flex flex-col items-center justify-center"
                    style={{ minHeight: '300px' }}
                  >
                    <div className="text-center">
                      <Camera className="w-12 h-12 text-red-500 mx-auto mb-3" />
                      <p className="text-red-700 font-medium mb-2">Camera Error</p>
                      <p className="text-red-600 text-sm mb-4">{cameraError}</p>
                      <button
                        onClick={() => {
                          setCameraError(null);
                          startCamera();
                        }}
                        className="bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700 transition-colors"
                      >
                        Try Again
                      </button>
                    </div>
                  </div>
                )}
                <video
                  ref={videoRef}
                  autoPlay
                  playsInline
                  muted
                  className={`w-full rounded-xl mb-4 bg-black ${
                    cameraLoading || cameraError ? 'hidden' : 'block'
                  }`}
                  style={{ minHeight: '300px', maxHeight: '500px', objectFit: 'cover' }}
                />
                <canvas ref={canvasRef} className="hidden" />
                <div className="flex gap-3">
                  <button
                    onClick={stopCamera}
                    className="flex-1 px-4 py-3 border-2 border-blue-600 rounded-xl text-blue-600 font-medium hover:bg-blue-50 transition-colors"
                  >
                    Cancel
                  </button>
                  <button
                    onClick={capturePhoto}
                    disabled={cameraLoading || !!cameraError}
                    className="flex-1 px-4 py-3 bg-blue-600 text-white rounded-xl font-medium hover:bg-blue-700 transition-colors shadow-md disabled:bg-blue-400 disabled:cursor-not-allowed"
                  >
                    {cameraLoading ? 'Loading...' : 'Capture'}
                  </button>
                </div>
              </div>
            </div>
          )}
        </div>
      </InspectorLayout>
    </ProtectedRoute>
  );
};

export default HSEObservationForm;
